#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linktoc=all,
    linkcolor=black,
}
\makeatletter\@addtoreset{section}{part}\makeatother
\titleformat{\part}[display]{\bfseries\huge}{Unidad\ \thepart}{0.2ex}{}[]
\end_preamble
\use_default_options true
\begin_modules
theorems-bytype
customHeadersFooters
enumitem
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing other 1.45
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3.5cm
\rightmargin 2.5cm
\bottommargin 3.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
Estructuras de Datos y Algoritmos I - Trabajo Práctico Final
\end_layout

\begin_layout Right Header
Matías Palumbo
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hspace{-1.2cm}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale= 0.8]{header2}     
\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

	
\backslash
vfill                  
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.7cm}             
\end_layout

\begin_layout Plain Layout


\backslash
noindent
\backslash
textbf{
\backslash
Huge Trabajo Práctico Final}
\backslash
par           
\end_layout

\begin_layout Plain Layout


\backslash
vspace{2cm}   
\end_layout

\begin_layout Plain Layout


\backslash
noindent
\backslash
LARGE Palumbo, Matías
\backslash
par 
\end_layout

\begin_layout Plain Layout


\backslash
vfill           
\end_layout

\begin_layout Plain Layout


\backslash
large Universidad Nacional de Rosario 
\backslash
par         
\end_layout

\begin_layout Plain Layout


\backslash
noindent
\backslash
large 2020     
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right
ewifnweiognwe
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
A continuación, se detallan las decisiones en general y particularidades
 en el proceso de diseño y desarrollo del Intérprete.
 El Trabajo Práctico fue realizado en su totalidad en el sistema operativo
 Mac OS 10.15.6.
 Se testeó tanto en Mac OS como en Ubuntu 18.04 LTS.
 Además, se monitoreó y optimizó el manejo de la memoria corriendo el programa
 con Valgrind en la misma versión de Ubuntu.
\end_layout

\begin_layout Section
Estructuras de Datos Utilizadas
\end_layout

\begin_layout Subsection
Conjuntos
\end_layout

\begin_layout Standard
Se decidió implementar conjuntos de enteros en C mediante árboles AVL de
 intervalos.
 Si bien los elementos de cada conjunto son números enteros en su naturaleza,
 juntar enteros consecutivos en intervalos permite optimizar y unificar
 completamente la creación de conjuntos por comprensión y por extensión.
 Al crear un conjunto por comprensión, simplemente se inserta el intervalo
 correspondiente en un árbol (o no, si el conjunto ingresado es vacío).
 Por otro lado, al crear por extensión, se comienza insertando los elementos
 como intervalos unitarios, y la función que inserta elementos en el árbol
 une intervalos que se intersequen o sean consecutivos, y posteriormente
 busca repeticiones de algún intervalo contenido en ese en los subárboles.
 Esto resulta en que, en un árbol dado, todos los intervalos que lo componen
 son disjuntos dos a dos, no repitiéndose ningún entero.
 Además, la impresión de un conjunto es óptima, al estar unidos todos los
 intervalos de enteros consecutivos.
\end_layout

\begin_layout Standard
Implementar conjuntos de esta manera tiene la ventaja de que, siendo 
\begin_inset Formula $n$
\end_inset

 la cantidad de nodos que posee el árbol que representa al conjunto, las
 operaciones de inserción y eliminación son 
\begin_inset Formula $O(\log n)$
\end_inset

 en tiempo, es decir, proporcionales a la altura del árbol.
 Como estas dos operaciones son las básicas de un árbol binario, la elección
 de esta estructura presenta una optimización general en el cálculo de operacion
es entre conjuntos, en contraposición con, por ejemplo, listas enlazadas.
\end_layout

\begin_layout Subsection
Almacenamiento de Conjuntos en Memoria
\end_layout

\begin_layout Standard
Se utilizan Tablas Hash para almacenar los conjuntos ingresados en memoria.
 Las Tablas Hash implementadas presentan las siguientes características:
\end_layout

\begin_layout Itemize
El tamaño inicial de la tabla utilizada en el Intérprete es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|HASH_TABLE_DEF_SIZE|
\end_layout

\end_inset

 
\begin_inset Formula $=32=2^{5}$
\end_inset

.
\end_layout

\begin_layout Itemize
Una vez que el factor de carga de la tabla supera 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|LIM_FACTOR_CARGA|
\end_layout

\end_inset

 
\begin_inset Formula $=0.75$
\end_inset

, se procede a redimensionarla, duplicando la capacidad de la misma.
\end_layout

\begin_layout Itemize
Se utiliza una segunda función de hash en caso de que la casilla accedida
 esté ocupada, la cual devuelve el valor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|INTV_HASH_DOBLE|
\end_layout

\end_inset

 
\begin_inset Formula $=7$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Se puede observar que como el tamaño inicial de la tabla (y todos los tamaños
 resultantes de redimensionarla) son potencias de 2, y el intervalo de sondeo
 es el número primo 7, siempre se recorrerán todas las casillas de la tabla
 en busca de un lugar disponible.
 Efectivamente, tomando el tamaño de la tabla 
\begin_inset Formula $N=2^{r}$
\end_inset

 (con 
\begin_inset Formula $r\geq5$
\end_inset

) en un momento dado, sus divisores son de la forma 
\begin_inset Formula $2^{k},\ 0\leq k\leq r$
\end_inset

, todos pares.
 Entonces, el tamaño de la tabla y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|INTV_HASH_DOBLE|
\end_layout

\end_inset

 son primos relativos, quedando demostrado.
\end_layout

\begin_layout Standard
La elección de Tabla Hash como estructura para almacenar los conjuntos permite
 acceder rápidamente a la casilla con la clave dada, así como también insertar
 y eliminar conjuntos eficientemente.
 A su vez, se permite especificar funciones destructoras de claves y datos
 para manejar adecuadamente la memoria al eliminar elementos y destruir
 la tabla.
\end_layout

\begin_layout Subsection
Estado
\end_layout

\begin_layout Standard
Se definen en el archivo de cabecera 
\begin_inset Quotes qld
\end_inset

estado.h
\begin_inset Quotes qld
\end_inset

 dos enum útiles para representar las acciones que el intérprete puede seguir.
 El primero, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|enum EstadoInput|
\end_layout

\end_inset

, tiene un valor por cada comando válido del intérprete, es decir, cada
 tipo de creación, imprimir un conjunto, salir, y realizar cada una de las
 operaciones.
 El otro, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|enum TipoError|
\end_layout

\end_inset

, es utilizado para representar los tipos de errores contemplados en el
 uso del intérprete, explicados más detalladamente en la Sección 3.2.
 
\end_layout

\begin_layout Standard
Adicionalmente, para mantener centralizadas en un mismo lugar las variables
 necesitadas por el intérprete, se hace uso de la estructura Estado, la
 cual guarda, entre otras cosas, los conjuntos con los cuales se opera,
 y el conjunto a guardar en memoria.
\end_layout

\begin_layout Section
Particularidades del Intérprete
\end_layout

\begin_layout Subsection
Formatos Aceptados para los Alias
\end_layout

\begin_layout Standard
A continuación se enumeran los comando considerados válidos en el intérprete.
 Una observación importante es que no se premite crear conjuntos cuyo primer
 caracter sea 
\begin_inset Quotes qld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|~|
\end_layout

\end_inset


\begin_inset Quotes qld
\end_inset

 o 
\begin_inset Quotes qld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|{|
\end_layout

\end_inset


\begin_inset Quotes qld
\end_inset

.
 Hacerlo resultará en comandos considerados no válidos.
 En el siguiente listado se asume que los alias de conjuntos creados son
 válidos.
\end_layout

\begin_layout Itemize
Salir: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|salir|
\end_layout

\end_inset

 (sale del intérprete).
\end_layout

\begin_layout Itemize
Imprimir un conjunto: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|imprimir alias|
\end_layout

\end_inset

 (si existe 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias|
\end_layout

\end_inset

, lo imprime en orden, expresando como intervalo las secciones del conjunto
 que puedan serlo).
\end_layout

\begin_layout Itemize
Creación de un conjunto por extensión: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias = {1,2,3,4,5}|
\end_layout

\end_inset

 (el alias seguido de 
\begin_inset Quotes qld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb| = {|
\end_layout

\end_inset


\begin_inset Quotes qld
\end_inset

 y una sucesión de enteros separados por coma terminada con 
\begin_inset Quotes qld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|}|
\end_layout

\end_inset


\begin_inset Quotes qld
\end_inset

).
\end_layout

\begin_layout Itemize
Creación de un conjunto por comprensión: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias = {x : n1 <= x <= n2}|
\end_layout

\end_inset

, donde 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|x|
\end_layout

\end_inset

 puede ser cualquier letra, y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|n1|
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|n2|
\end_layout

\end_inset

 son enteros.
 Si 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|n1|
\end_layout

\end_inset

 es mayor que 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|n2|
\end_layout

\end_inset

, el conjunto es considerado vacío.
\end_layout

\begin_layout Itemize
Complemento de un conjunto: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1 = ~alias2|
\end_layout

\end_inset

 (si existe 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2|
\end_layout

\end_inset

, calcula su complemento y lo almacena con el nombre 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1|
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
Intersección entre conjuntos: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1 = alias2 & alias3|
\end_layout

\end_inset

 (si existen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2|
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias3|
\end_layout

\end_inset

, calcula su intersección y la almacena en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1|
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
Unión entre conjuntos: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb!alias1 = alias2 | alias3!
\end_layout

\end_inset

 (si existen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2|
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias3|
\end_layout

\end_inset

, calcula su unión y la almacena en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1|
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
Resta de un conjunto con otro: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1 = alias2 - alias3|
\end_layout

\end_inset

 (si existen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2|
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias3|
\end_layout

\end_inset

, calcula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2 - alias3|
\end_layout

\end_inset

, y lo almacena en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1|
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
Igualación de conjuntos: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1 = alias2|
\end_layout

\end_inset

 (si existe 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias2|
\end_layout

\end_inset

, crea una copia de él y la almacena en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|alias1|
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsection
Manejo de Errores
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|enum TipoError|
\end_layout

\end_inset

 presenta los siguientes valores, cada uno permitendo distinguir distintos
 tipos de errores: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|NoError|
\end_layout

\end_inset

: Ausencia de error.
 Utilizado para inicializar y preparar el Estado.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|ComandoNoValido|
\end_layout

\end_inset

: Contempla el caso en el que no se respete el formato preestablecido.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|ConjuntoInexistente|
\end_layout

\end_inset

: Contempla el caso en el que el comando sea válido pero los conjuntos a
 utilizar no existan.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|ElementosNoValidos|
\end_layout

\end_inset

: Contempla el caso en el que al crear un conjunto se ingrese algún número
 que supere los límites de enteros en C.
\end_layout

\begin_layout Section
Compilación del Programa
\end_layout

\begin_layout Standard
Los archivos necesarios en la compilación del programa y sus dependencias
 se encuentran detallados en el archivo 
\emph on
makefile
\emph default
.
 Para compilar el mismo, sólo es necesario correr cualquiera de los siguientes
 dos comandos en la terminal: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}make
\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}make interprete
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Luego, el intérprete se inicializa con el comando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}./interprete
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Dificultades Encontradas
\end_layout

\begin_layout Section
Bibliografía
\end_layout

\end_body
\end_document
