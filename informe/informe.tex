%% LyX 2.3.4.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[spanish]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3.5cm,bmargin=3.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{enumitem}
\usepackage{setspace}
\setstretch{1.45}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newlength{\lyxlabelwidth}      % auxiliary length 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linktoc=all,
    linkcolor=black,
}
\makeatletter\@addtoreset{section}{part}\makeatother
\titleformat{\part}[display]{\bfseries\huge}{Unidad\ \thepart}{0.2ex}{}[]

\makeatother

\usepackage{babel}
\addto\shorthandsspanish{\spanishdeactivate{~<>}}

\begin{document}

\lhead{Estructuras de Datos y Algoritmos I - Trabajo Práctico Final}

\rhead{Matías Palumbo}

\begin{titlepage}

\begin{wrapfigure}{o}{0.25\columnwidth}%
\begin{centering} \includegraphics[scale=0.5]{logo}\hspace*{\fill}$\begin{array}{r} \text{\text{Facultad de Ciencias Exactas, Ingeniería y Agrimensura}}\\ \text{\text{Escuela de Ciencias Exactas y Naturales}}\\ \text{\text{Departamento de Ciencias de la Computación}}\\ \text{\text{Estructuras de Datos y Algoritmos I}} \end{array}$ \par\end{centering} \end{wrapfigure}% 



\hspace{-1.2cm}
\includegraphics[scale= 0.8]{header2}     \begin{center}
	\vfill                  
\vspace{0.7cm}             
\noindent\textbf{\Huge Trabajo Práctico Final}\par           
\vspace{2cm}   
\noindent\LARGE Palumbo, Matías\par 
\vfill           
\large Universidad Nacional de Rosario \par         
\noindent\large 2020     
\end{center} 
\end{titlepage}
\begin{flushright}
ewifnweiognwe
\par\end{flushright}

\section{Introducción}

A continuación, se detallan las decisiones en general y particularidades
en el proceso de diseño y desarrollo del Intérprete. El Trabajo Práctico
fue realizado en su totalidad en el sistema operativo Mac OS 10.15.6.
Se testeó tanto en Mac OS como en Ubuntu 18.04 LTS. Además, se monitoreó
y optimizó el manejo de la memoria corriendo el programa con Valgrind
en la misma versión de Ubuntu.

\section{Estructuras de Datos Utilizadas}

\subsection{Conjuntos}

Se decidió implementar conjuntos de enteros en C mediante árboles
AVL de intervalos. Si bien los elementos de cada conjunto son enteros
en su naturaleza, juntar enteros consecutivos en intervalos permite
optimizar y unificar completamente la creación de conjuntos por comprensión
y por extensión. Al crear un conjunto por comprensión, simplemente
se inserta el intervalo correspondiente en un árbol (o no, si el conjunto
ingresado es vacío). Por otro lado, al crear por extensión, se comienza
insertando los elementos como intervalos unitarios, y la función que
inserta elementos en el árbol une intervalos que se intersequen o
sean consecutivos, y posteriormente busca repeticiones de algún intervalo
contenido en ese en los subárboles. Esto resulta en que, en un árbol
dado, todos los intervalos que lo componen son disjuntos dos a dos,
no repitiéndose ningún entero. Además, la impresión de un conjunto
es óptima, al estar unidos todos los intervalos de enteros consecutivos.

Implementar conjuntos de esta manera tiene la ventaja de que, siendo
$n$ la cantidad de nodos que posee el árbol que representa al conjunto,
las operaciones de inserción y eliminación son $O(\log n)$ en tiempo,
es decir, proporcionales a la altura del árbol. Como estas dos operaciones
son las básicas de un árbol binario, la elección de esta estructura
presenta una optimización general en el cálculo de operaciones entre
conjuntos, en contraposición con, por ejemplo, listas enlazadas.

\subsection{Almacenamiento de Conjuntos en Memoria}

Se utilizan Tablas Hash para almacenar los conjuntos ingresados en
memoria. Las Tablas Hash implementadas presentan las siguientes características:
\begin{itemize}
\item El tamaño inicial de la tabla utilizada en el Intérprete es \verb|HASH_TABLE_DEF_SIZE|
$=32=2^{5}$.
\item Una vez que el factor de carga de la tabla supera \verb|LIM_FACTOR_CARGA|
$=0.75$, se procede a redimensionarla, duplicando la capacidad de
la misma.
\item Se utiliza una segunda función de hash en caso de que la casilla accedida
esté ocupada, la cual devuelve el valor \verb|INTV_HASH_DOBLE| $=7$.
\end{itemize}
%
Se puede observar que como el tamaño inicial de la tabla (y todos
los tamaños resultantes de redimensionarla) son potencias de 2, y
el intervalo de sondeo es el número primo 7, siempre se recorrerán
todas las casillas de la tabla en busca de un lugar disponible. Efectivamente,
tomando el tamaño de la tabla $N=2^{r}$ (con $r\geq5$) en un momento
dado, sus divisores son de la forma $2^{k},\ 0\leq k\leq r$, todos
pares. Entonces, el tamaño de la tabla y \verb|INTV_HASH_DOBLE| son
primos relativos, quedando demostrado.

La elección de Tabla Hash como estructura para almacenar los conjuntos
permite acceder rápidamente a la casilla con la clave dada, así como
también insertar y eliminar conjuntos eficientemente. A su vez, se
permite especificar funciones destructoras de claves y datos para
manejar adecuadamente la memoria al eliminar elementos y destruir
la tabla.

\subsection{Estado}

Se definen en el archivo de cabecera \textquotedbl estado.h\textquotedbl{}
dos enum útiles para representar las acciones que el intérprete puede
seguir. El primero, \verb|enum EstadoInput|, tiene un valor por cada
comando válido del intérprete, es decir, cada tipo de creación, imprimir
un conjunto, salir, y realizar cada una de las operaciones. El otro,
\verb|enum TipoError|, es utilizado para representar los tipos de
errores contemplados en el uso del intérprete, explicados más detalladamente
en la Sección 3.2. 

Adicionalmente, para mantener centralizadas en un mismo lugar las
variables necesitadas por el intérprete, se hace uso de la estructura
Estado, la cual guarda, entre otras cosas, los conjuntos con los cuales
se opera, y el conjunto a guardar en memoria.

\section{Particularidades del Intérprete}

\subsection{Formatos Aceptados para los Alias}

A continuación se enumeran los comando considerados válidos en el
intérprete. Una observación importante es que no se premite crear
conjuntos cuyo primer caracter sea \textquotedbl\verb|~|\textquotedbl{}
o \textquotedbl\verb|{|\textquotedbl . Hacerlo resultará en comandos
considerados no válidos. En el siguiente listado se asume que los
alias de conjuntos creados son válidos.
\begin{itemize}
\item Salir: \verb|salir| (sale del intérprete).
\item Imprimir un conjunto: \verb|imprimir alias| (si existe \verb|alias|,
lo imprime en orden, expresando como intervalo las secciones del conjunto
que puedan serlo).
\item Creación de un conjunto por extensión: \verb|alias = {1,2,3,4,5}|
(el alias seguido de \textquotedbl\verb| = {|\textquotedbl{} y una
sucesión de enteros separados por coma terminada con \textquotedbl\verb|}|\textquotedbl ).
\item Creación de un conjunto por comprensión: \verb|alias = {x : n1 <= x <= n2}|,
donde \verb|x| puede ser cualquier letra, y \verb|n1| y \verb|n2|
son enteros. Si \verb|n1| es mayor que \verb|n2|, el conjunto es
considerado vacío.
\item Complemento de un conjunto: \verb|alias1 = ~alias2| (si existe \verb|alias2|,
calcula su complemento y lo almacena con el nombre \verb|alias1|).
\item Intersección entre conjuntos: \verb|alias1 = alias2 & alias3| (si
existen \verb|alias2| y \verb|alias3|, calcula su intersección y
la almacena en \verb|alias1|).
\item Unión entre conjuntos: \verb!alias1 = alias2 | alias3! (si existen
\verb|alias2| y \verb|alias3|, calcula su unión y la almacena en
\verb|alias1|).
\item Resta de un conjunto con otro: \verb|alias1 = alias2 - alias3| (si
existen \verb|alias2| y \verb|alias3|, calcula \verb|alias2 - alias3|,
y lo almacena en \verb|alias1|).
\item Igualación de conjuntos: \verb|alias1 = alias2| (si existe \verb|alias2|,
crea una copia de él y la almacena en \verb|alias1|).
\end{itemize}

\subsection{Manejo de Errores}

\verb|enum TipoError| presenta los siguientes valores, cada uno permitendo
distinguir distintos tipos de errores: 
\begin{itemize}
\item \verb|NoError|: Ausencia de error. Utilizado para inicializar y preparar
el Estado.
\item \verb|ComandoNoValido|: Contempla el caso en el que no se respete
el formato preestablecido.
\item \verb|ConjuntoInexistente|: Contempla el caso en el que el comando
sea válido pero los conjuntos a utilizar no existan.
\item \verb|ElementosNoValidos|: Contempla el caso en el que al crear un
conjunto se ingrese algún número que supere los límites de enteros
en C.
\end{itemize}

\section{Compilación del Programa}

Los archivos necesarios en la compilación del programa y sus dependencias
se encuentran detallados en el archivo \emph{makefile}. Para compilar
el mismo, sólo es necesario correr cualquiera de los siguientes dos
comandos en la terminal: \begin{verbatim}make\end{verbatim}\begin{verbatim}make interprete\end{verbatim}

Luego, el intérprete se inicializa con el comando \begin{verbatim}./interprete\end{verbatim}

\section{Dificultades Encontradas}

\section{Bibliografía}
\end{document}
